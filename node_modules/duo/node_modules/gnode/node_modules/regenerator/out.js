/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var range = regeneratorRuntime.mark(function range(n) {
  var i;

  return regeneratorRuntime.wrap(function range$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
    case 0:
      i = 0;
    case 1:
      if (!(i < n)) {
        context$1$0.next = 7;
        break;
      }

      context$1$0.next = 4;
      return i;
    case 4:
      ++i;
      context$1$0.next = 1;
      break;
    case 7:
    case "end":
      return context$1$0.stop();
    }
  }, range, this);
});

/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

var assert = require("assert");
var runningInTranslation = /\.wrap\(/.test(regeneratorRuntime.mark(function callee$0$0() {
  return regeneratorRuntime.wrap(function callee$0$0$(context$1$0) {
    while (1) switch (context$1$0.prev = context$1$0.next) {
    case 0:
    case "end":
      return context$1$0.stop();
    }
  }, callee$0$0, this);
}));

function check(g, yields, returnValue) {
  for (var i = 0; i < yields.length; ++i) {
    var info = i > 0 ? g.next(i) : g.next();
    assert.deepEqual(info.value, yields[i]);
    assert.strictEqual(info.done, false);
  }

  assert.deepEqual(
    i > 0 ? g.next(i) : g.next(),
    { value: returnValue, done: true }
  );
}

// A version of `throw` whose behavior can't be statically analyzed.
// Useful for testing dynamic exception dispatching.
function raise(argument) {
  throw argument;
}

function assertAlreadyFinished(generator) {
  try {
    generator.next();
    assert.ok(false, "should have thrown an exception");
  } catch (err) {
    assert.ok(err instanceof Error);
    assert.strictEqual(
      err.message,
      "Generator has already finished"
    );
  }
}

describe("regeneratorRuntime", function() {
  it("should be defined globally", function() {
    var global = Function("return this")();
    assert.ok("regeneratorRuntime" in global);
    assert.strictEqual(global.regeneratorRuntime, regeneratorRuntime);
  });

  it("should have a .wrap method", function() {
    assert.strictEqual(typeof regeneratorRuntime.wrap, "function");
  });

  it("should have a .mark method", function() {
    assert.strictEqual(typeof regeneratorRuntime.mark, "function");
  });

  it("should be the object name returned by util.runtimeProperty", function() {
    assert.strictEqual(
      require("../lib/util").runtimeProperty("foo").object.name,
      "regeneratorRuntime"
    );
  });
});

(runningInTranslation ? describe : xdescribe)("@@iterator", function() {
  var iteratorSymbol = typeof Symbol === "function"
    && Symbol.iterator
    || "@@iterator";

  it("is defined on Generator.prototype and returns this", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var iterator = gen();
    assert.ok(!iterator.hasOwnProperty(iteratorSymbol));
    assert.ok(!Object.getPrototypeOf(iterator).hasOwnProperty(iteratorSymbol));
    assert.ok(Object.getPrototypeOf(
      Object.getPrototypeOf(iterator)
    ).hasOwnProperty(iteratorSymbol));
    assert.strictEqual(iterator[iteratorSymbol](), iterator);
  });
});

describe("simple argument yielder", function() {
  it("should yield only its first argument", function() {
    var gen = regeneratorRuntime.mark(function gen(x) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return x;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen("oyez"), ["oyez"]);
    check(gen("foo", "bar"), ["foo"]);
  });

  it("should support multiple yields in expression", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
          context$3$0.t0 = context$3$0.sent;
          context$3$0.next = 5;
          return 0;
        case 5:
          context$3$0.t1 = context$3$0.sent;
          return context$3$0.abrupt("return", context$3$0.t0 + context$3$0.t1);
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var itr = gen();
    itr.next();
    itr.next(1);
    assert.equal(itr.next(2).value, 3);
  });
});

describe("range generator", function() {
  it("should yield the empty range", function() {
    check(range(0), []);
  })

  it("should yield the range 0..n-1", function() {
    check(range(5), [0, 1, 2, 3, 4]);
  });
});

describe("collatz generator", function() {
  var gen = regeneratorRuntime.mark(function gen(n) {
    var count;

    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        count = 0;
        context$2$0.next = 3;
        return n;
      case 3:
        if (!(n !== 1)) {
          context$2$0.next = 14;
          break;
        }

        count += 1;

        if (!(n % 2)) {
          context$2$0.next = 10;
          break;
        }

        context$2$0.next = 8;
        return n = n * 3 + 1;
      case 8:
        context$2$0.next = 12;
        break;
      case 10:
        context$2$0.next = 12;
        return n >>= 1;
      case 12:
        context$2$0.next = 3;
        break;
      case 14:
        return context$2$0.abrupt("return", count);
      case 15:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this);
  });

  function collatz(n) {
    var result = [n];

    while (n !== 1) {
      if (n % 2) {
        n *= 3;
        n += 1;
      } else {
        n >>= 1;
      }

      result.push(n);
    }

    return result;
  }

  var seven = collatz(7);
  var fiftyTwo = seven.slice(seven.indexOf(52));
  var eightyTwo = collatz(82);

  it("seven", function() {
    check(gen(7), seven, 16);
  });

  it("fifty two", function() {
    check(gen(52), fiftyTwo, 11);
  });

  it("eighty two", function() {
    check(gen(82), eightyTwo, 110);
  });
});

describe("throw", function() {
  (runningInTranslation ? it : xit)("should complete generator", function() {
    var gen = regeneratorRuntime.mark(function gen(x) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          throw 1;
        case 1:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var u = gen();

    try {
      u.next();
    } catch (err) {
      assert.strictEqual(err, 1);
    }

    assertAlreadyFinished(u);
  });
});

describe("try-catch generator", function() {
  var usingThrow = regeneratorRuntime.mark(function usingThrow(x) {
    return regeneratorRuntime.wrap(function usingThrow$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return 0;
      case 2:
        context$2$0.prev = 2;
        context$2$0.next = 5;
        return 1;
      case 5:
        if (!(x % 2 === 0)) {
          context$2$0.next = 7;
          break;
        }

        throw 2;
      case 7:
        context$2$0.next = 9;
        return x;
      case 9:
        context$2$0.next = 15;
        break;
      case 11:
        context$2$0.prev = 11;
        context$2$0.t2 = context$2$0.catch(2);
        context$2$0.next = 15;
        return context$2$0.t2;
      case 15:
        context$2$0.next = 17;
        return 3;
      case 17:
      case "end":
        return context$2$0.stop();
      }
    }, usingThrow, this, [[2, 11]]);
  });

  var usingRaise = regeneratorRuntime.mark(function usingRaise(x) {
    return regeneratorRuntime.wrap(function usingRaise$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return 0;
      case 2:
        context$2$0.prev = 2;
        context$2$0.next = 5;
        return 1;
      case 5:
        if (x % 2 === 0)
          raise(2);
        context$2$0.next = 8;
        return x;
      case 8:
        context$2$0.next = 14;
        break;
      case 10:
        context$2$0.prev = 10;
        context$2$0.t3 = context$2$0.catch(2);
        context$2$0.next = 14;
        return context$2$0.t3;
      case 14:
        context$2$0.next = 16;
        return 3;
      case 16:
      case "end":
        return context$2$0.stop();
      }
    }, usingRaise, this, [[2, 10]]);
  });

  it("should catch static exceptions properly", function() {
    check(usingThrow(4), [0, 1, 2, 3]);
    check(usingThrow(5), [0, 1, 5, 3]);
  });

  it("should catch dynamic exceptions properly", function() {
    check(usingRaise(4), [0, 1, 2, 3]);
    check(usingRaise(5), [0, 1, 5, 3]);
  });
});

describe("nested generators in try-catch", function() {
  var gen = regeneratorRuntime.mark(function gen() {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.prev = 0;
        nonExistent;
        context$2$0.next = 8;
        break;
      case 4:
        context$2$0.prev = 4;
        context$2$0.t4 = context$2$0.catch(0);
        context$2$0.next = 8;

        return regeneratorRuntime.mark(function callee$3$0() {
          return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
            while (1) switch (context$4$0.prev = context$4$0.next) {
            case 0:
              context$4$0.next = 2;
              return context$2$0.t4;
            case 2:
            case "end":
              return context$4$0.stop();
            }
          }, callee$3$0, this);
        });
      case 8:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this, [[0, 4]]);
  });

  it('should get a reference to the caught error', function () {
    var genFun2 = gen().next().value;
    assert.ok(regeneratorRuntime.isGeneratorFunction(genFun2));
    var gen2 = genFun2();
    var res = gen2.next();
    assert.ok(res.value instanceof ReferenceError);
    // Note that we don't do strict equality over the message because it varies
    // across browsers (if we ever want to run tests in browsers).
    assert.ok(res.value.message.match(/nonExistent/));
  });
});

describe("try-finally generator", function() {
  var usingThrow = regeneratorRuntime.mark(function usingThrow(condition) {
    return regeneratorRuntime.wrap(function usingThrow$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return 0;
      case 2:
        context$2$0.prev = 2;
        context$2$0.next = 5;
        return 1;
      case 5:
        throw 2;
      case 8:
        context$2$0.prev = 8;

        if (!condition) {
          context$2$0.next = 13;
          break;
        }

        context$2$0.next = 12;
        return 4;
      case 12:
        return context$2$0.abrupt("return", 5);
      case 13:
        context$2$0.next = 15;
        return 6;
      case 15:
        return context$2$0.abrupt("return", 7);
      case 17:
      case "end":
        return context$2$0.stop();
      }
    }, usingThrow, this, [[2,, 8]]);
  });

  var usingRaise = regeneratorRuntime.mark(function usingRaise(condition) {
    return regeneratorRuntime.wrap(function usingRaise$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return 0;
      case 2:
        context$2$0.prev = 2;
        context$2$0.next = 5;
        return 1;
      case 5:
        raise(2);
        context$2$0.next = 8;
        return 3;
      case 8:
        context$2$0.prev = 8;

        if (!condition) {
          context$2$0.next = 13;
          break;
        }

        context$2$0.next = 12;
        return 4;
      case 12:
        return context$2$0.abrupt("return", 5);
      case 13:
        context$2$0.next = 15;
        return 6;
      case 15:
        return context$2$0.abrupt("return", 7);
      case 17:
      case "end":
        return context$2$0.stop();
      }
    }, usingRaise, this, [[2,, 8]]);
  });

  it("should execute finally blocks statically", function() {
    check(usingThrow(true), [0, 1, 4], 5);
    check(usingThrow(false), [0, 1, 6], 7);
  });

  it("should execute finally blocks dynamically", function() {
    check(usingRaise(true), [0, 1, 4], 5);
    check(usingRaise(false), [0, 1, 6], 7);
  });

  it("should execute finally blocks before throwing", function() {
    var uncaught = regeneratorRuntime.mark(function uncaught(condition) {
      return regeneratorRuntime.wrap(function uncaught$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          context$3$0.next = 3;
          return 0;
        case 3:
          if (!condition) {
            context$3$0.next = 7;
            break;
          }

          context$3$0.next = 6;
          return 1;
        case 6:
          raise(uncaughtError);
        case 7:
          context$3$0.next = 9;
          return 2;
        case 9:
          context$3$0.prev = 9;
          context$3$0.next = 12;
          return 3;
        case 12:
          context$3$0.finish(9);
        case 13:
          context$3$0.next = 15;
          return 4;
        case 15:
        case "end":
          return context$3$0.stop();
        }
      }, uncaught, this, [[0,, 9]]);
    });

    var uncaughtError = new Error("uncaught");

    check(uncaught(false), [0, 2, 3, 4]);

    var u = uncaught(true);

    assert.deepEqual(u.next(), { value: 0, done: false });
    assert.deepEqual(u.next(), { value: 1, done: false });
    assert.deepEqual(u.next(), { value: 3, done: false });

    try {
      u.next();
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, uncaughtError);
    }
  });

  it("should throw correct error when finally contains catch", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          context$3$0.next = 3;
          return 0;
        case 3:
          raise(right);
        case 4:
          context$3$0.prev = 4;
          context$3$0.next = 7;
          return 1;
        case 7:
          context$3$0.prev = 7;
          raise(wrong);
          context$3$0.next = 16;
          break;
        case 11:
          context$3$0.prev = 11;
          context$3$0.t5 = context$3$0.catch(7);
          assert.strictEqual(context$3$0.t5, wrong);
          context$3$0.next = 16;
          return 2;
        case 16:
          context$3$0.finish(4);
        case 17:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[0,, 4], [7, 11]]);
    });

    var right = new Error("right");
    var wrong = new Error("wrong");

    var g = gen();

    assert.deepEqual(g.next(), {
      value: 0,
      done: false
    });

    assert.deepEqual(g.next(), {
      value: 1,
      done: false
    });

    assert.deepEqual(g.next(), {
      value: 2,
      done: false
    });

    try {
      g.next();
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, right);
    }
  });
});

describe("try-catch-finally generator", function() {
  var usingThrow = regeneratorRuntime.mark(function usingThrow() {
    return regeneratorRuntime.wrap(function usingThrow$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return 0;
      case 2:
        context$2$0.prev = 2;
        context$2$0.prev = 3;
        context$2$0.next = 6;
        return 1;
      case 6:
        throw 2;
      case 9:
        context$2$0.next = 16;
        break;
      case 11:
        context$2$0.prev = 11;
        context$2$0.t6 = context$2$0.catch(3);
        context$2$0.next = 15;
        return context$2$0.t6;
      case 15:
        throw context$2$0.sent;
      case 16:
        context$2$0.prev = 16;
        context$2$0.next = 19;
        return 5;
      case 19:
        context$2$0.finish(16);
      case 20:
        context$2$0.next = 26;
        break;
      case 22:
        context$2$0.prev = 22;
        context$2$0.t7 = context$2$0.catch(2);
        context$2$0.next = 26;
        return context$2$0.t7;
      case 26:
        context$2$0.next = 28;
        return 6;
      case 28:
      case "end":
        return context$2$0.stop();
      }
    }, usingThrow, this, [[2, 22], [3, 11, 16]]);
  });

  var usingRaise = regeneratorRuntime.mark(function usingRaise() {
    return regeneratorRuntime.wrap(function usingRaise$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return 0;
      case 2:
        context$2$0.prev = 2;
        context$2$0.prev = 3;
        context$2$0.next = 6;
        return 1;
      case 6:
        raise(2);
        context$2$0.next = 9;
        return 3;
      case 9:
        context$2$0.next = 16;
        break;
      case 11:
        context$2$0.prev = 11;
        context$2$0.t8 = context$2$0.catch(3);
        context$2$0.next = 15;
        return context$2$0.t8;
      case 15:
        throw context$2$0.sent;
      case 16:
        context$2$0.prev = 16;
        context$2$0.next = 19;
        return 5;
      case 19:
        context$2$0.finish(16);
      case 20:
        context$2$0.next = 26;
        break;
      case 22:
        context$2$0.prev = 22;
        context$2$0.t9 = context$2$0.catch(2);
        context$2$0.next = 26;
        return context$2$0.t9;
      case 26:
        context$2$0.next = 28;
        return 6;
      case 28:
      case "end":
        return context$2$0.stop();
      }
    }, usingRaise, this, [[2, 22], [3, 11, 16]]);
  });

  it("should statically catch and then finalize", function() {
    check(usingThrow(), [0, 1, 2, 5, 3, 6]);
  });

  it("should dynamically catch and then finalize", function() {
    check(usingRaise(), [0, 1, 2, 5, 3, 6]);
  });
});

describe("dynamic exception", function() {
  var gen = regeneratorRuntime.mark(function gen(x, fname) {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.prev = 0;
        return context$2$0.abrupt("return", fns[fname](x));
      case 4:
        context$2$0.prev = 4;
        context$2$0.t10 = context$2$0.catch(0);
        context$2$0.next = 8;
        return context$2$0.t10;
      case 8:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this, [[0, 4]]);
  });

  var fns = {
    f: function(x) {
      throw x;
    },

    g: function(x) {
      return x;
    }
  };

  it("should be dispatched correctly", function() {
    check(gen("asdf", "f"), ["asdf"]);
    check(gen("asdf", "g"), [], "asdf");
  });
});

describe("nested finally blocks", function() {
  var usingThrow = regeneratorRuntime.mark(function usingThrow() {
    return regeneratorRuntime.wrap(function usingThrow$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.prev = 0;
        context$2$0.prev = 1;
        context$2$0.prev = 2;
        throw "thrown";
      case 4:
        context$2$0.prev = 4;
        context$2$0.next = 7;
        return 1;
      case 7:
        context$2$0.finish(4);
      case 8:
        context$2$0.next = 14;
        break;
      case 10:
        context$2$0.prev = 10;
        context$2$0.t11 = context$2$0.catch(1);
        context$2$0.next = 14;
        return context$2$0.t11;
      case 14:
        context$2$0.prev = 14;
        context$2$0.next = 17;
        return 2;
      case 17:
        context$2$0.finish(14);
      case 18:
        context$2$0.prev = 18;
        context$2$0.next = 21;
        return 3;
      case 21:
        context$2$0.finish(18);
      case 22:
      case "end":
        return context$2$0.stop();
      }
    }, usingThrow, this, [[0,, 18], [1, 10, 14], [2,, 4]]);
  });

  var usingRaise = regeneratorRuntime.mark(function usingRaise() {
    return regeneratorRuntime.wrap(function usingRaise$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.prev = 0;
        context$2$0.prev = 1;
        context$2$0.prev = 2;
        raise("thrown");
      case 4:
        context$2$0.prev = 4;
        context$2$0.next = 7;
        return 1;
      case 7:
        context$2$0.finish(4);
      case 8:
        context$2$0.next = 14;
        break;
      case 10:
        context$2$0.prev = 10;
        context$2$0.t12 = context$2$0.catch(1);
        context$2$0.next = 14;
        return context$2$0.t12;
      case 14:
        context$2$0.prev = 14;
        context$2$0.next = 17;
        return 2;
      case 17:
        context$2$0.finish(14);
      case 18:
        context$2$0.prev = 18;
        context$2$0.next = 21;
        return 3;
      case 21:
        context$2$0.finish(18);
      case 22:
      case "end":
        return context$2$0.stop();
      }
    }, usingRaise, this, [[0,, 18], [1, 10, 14], [2,, 4]]);
  });

  it("should statically execute in order", function() {
    check(usingThrow(), [1, "thrown", 2, 3]);
  });

  it("should dynamically execute in order", function() {
    check(usingRaise(), [1, "thrown", 2, 3]);
  });
});

describe("for-in loop generator", function() {
  it("should handle the simple case", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      var count, obj, key;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          count = 0;
          obj = {foo: 1, bar: 2};
          context$3$0.t13 = regeneratorRuntime.keys(obj);
        case 3:
          if ((context$3$0.t14 = context$3$0.t13()).done) {
            context$3$0.next = 11;
            break;
          }

          key = context$3$0.t14.value;
          assert(obj.hasOwnProperty(key), key + " must be own property");
          context$3$0.next = 8;
          return [key, obj[key]];
        case 8:
          count += 1;
          context$3$0.next = 3;
          break;
        case 11:
          return context$3$0.abrupt("return", count);
        case 12:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(), [["foo", 1], ["bar", 2]], 2);
  });

  it("should handle break in loop", function() {
    var gen = regeneratorRuntime.mark(function gen(obj) {
      var count, key;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          count = 0;
          context$3$0.next = 3;
          return "why not";
        case 3:
          context$3$0.t15 = regeneratorRuntime.keys(obj);
        case 4:
          if ((context$3$0.t16 = context$3$0.t15()).done) {
            context$3$0.next = 14;
            break;
          }

          key = context$3$0.t16.value;

          if (!obj.hasOwnProperty(key)) {
            context$3$0.next = 12;
            break;
          }

          if (!(key === "skip")) {
            context$3$0.next = 9;
            break;
          }

          return context$3$0.abrupt("break", 14);
        case 9:
          count += 1;
          context$3$0.next = 12;
          return [key, obj[key]];
        case 12:
          context$3$0.next = 4;
          break;
        case 14:
          return context$3$0.abrupt("return", count);
        case 15:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(
      gen({ a: 1, b: 2, skip: 3, c: 4 }),
      ["why not", ["a", 1], ["b", 2]],
      2
    );
  });

  it("should handle property deletion in loop", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      var count, obj, key;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          count = 0;
          obj = {foo: 1, bar: 2};
          context$3$0.t17 = regeneratorRuntime.keys(obj);
        case 3:
          if ((context$3$0.t18 = context$3$0.t17()).done) {
            context$3$0.next = 12;
            break;
          }

          key = context$3$0.t18.value;
          assert(obj.hasOwnProperty(key), key + " must be own property");
          context$3$0.next = 8;
          return [key, obj[key]];
        case 8:
          delete obj.bar;
          count += 1;
          context$3$0.next = 3;
          break;
        case 12:
          return context$3$0.abrupt("return", count);
        case 13:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(), [["foo", 1]], 1);
  });

  it("should loop over inherited properties", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      var count, Foo, foo, key;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          Foo = function Foo() {
            this.baz = 1
          };

          count = 0;
          Foo.prototype.bar = 2;

          foo = new Foo();
          context$3$0.t19 = regeneratorRuntime.keys(foo);
        case 5:
          if ((context$3$0.t20 = context$3$0.t19()).done) {
            context$3$0.next = 12;
            break;
          }

          key = context$3$0.t20.value;
          context$3$0.next = 9;
          return [key, foo[key]];
        case 9:
          count += 1;
          context$3$0.next = 5;
          break;
        case 12:
          return context$3$0.abrupt("return", count);
        case 13:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(), [["baz", 1], ["bar", 2]], 2);
  });

  it("should handle risky object expressions", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      var key;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          assert.ok(!a.called);
          assert.ok(!b.called);
          context$3$0.next = 4;
          return 0;
        case 4:
          context$3$0.t22 = context$3$0.sent;
          a(context$3$0.t22);
          context$3$0.next = 8;
          return 1;
        case 8:
          context$3$0.t23 = context$3$0.sent;
          context$3$0.t21 = regeneratorRuntime.keys(b(context$3$0.t23));
        case 10:
          if ((context$3$0.t24 = context$3$0.t21()).done) {
            context$3$0.next = 20;
            break;
          }

          key = context$3$0.t24.value;
          assert.ok(a.called);
          assert.ok(b.called);
          context$3$0.next = 16;
          return key;
        case 16:
          context$3$0.t25 = context$3$0.sent;
          assert.strictEqual(context$3$0.t25, 3);
          context$3$0.next = 10;
          break;
        case 20:
          context$3$0.t26 = regeneratorRuntime.keys((a(1), { foo: "foo", bar: "bar" }));
        case 21:
          if ((context$3$0.t27 = context$3$0.t26()).done) {
            context$3$0.next = 27;
            break;
          }

          key = context$3$0.t27.value;
          context$3$0.next = 25;
          return key;
        case 25:
          context$3$0.next = 21;
          break;
        case 27:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    function a(sent) {
      assert.strictEqual(sent, 1);
      a.called = true;
    }

    function b(sent) {
      assert.strictEqual(sent, 2);
      b.called = true;
      return { callee: b };
    }

    check(gen(), [0, 1, "callee", "foo", "bar"]);
  });
});

describe("yield chain", function() {
  var gen = regeneratorRuntime.mark(function gen(n) {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return n;
      case 2:
        context$2$0.next = 4;
        return context$2$0.sent;
      case 4:
        context$2$0.next = 6;
        return context$2$0.sent;
      case 6:
        context$2$0.next = 8;
        return context$2$0.sent;
      case 8:
        return context$2$0.abrupt("return", context$2$0.sent);
      case 9:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this);
  });

  it("should have correct associativity", function() {
    check(gen(5), [5, 1, 2, 3], 4);
    check(gen("asdf"), ["asdf", 1, 2, 3], 4);
  });
});

describe("object literal generator", function() {
  var gen = regeneratorRuntime.mark(function gen(a, b) {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return a;
      case 2:
        context$2$0.t28 = context$2$0.sent;
        context$2$0.t29 = a - context$2$0.t28;
        context$2$0.next = 6;
        return b;
      case 6:
        context$2$0.t30 = context$2$0.sent;
        context$2$0.next = 9;

        return {
          a: context$2$0.t29,
          b: context$2$0.t30
        };
      case 9:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this);
  });

  it("should yield the correct object", function() {
    check(gen(1, 2), [1, 2, { a: 0, b: 2 }]);
    check(gen(4, 2), [4, 2, { a: 3, b: 2 }]);
  });
});

describe("switch statement generator", function() {
  var gen = regeneratorRuntime.mark(function gen(a) {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.next = 2;
        return a;
      case 2:
        context$2$0.t31 = context$2$0.sent;
        context$2$0.next = 5;
        return "x";
      case 5:
        context$2$0.t32 = context$2$0.sent;
        context$2$0.t33 = context$2$0.t32 - a;

        if (!(context$2$0.t31 === context$2$0.t33)) {
          context$2$0.next = 11;
          break;
        }

        context$2$0.t34 = 23;
        context$2$0.next = 21;
        break;
      case 11:
        context$2$0.next = 13;
        return "y";
      case 13:
        context$2$0.t35 = context$2$0.sent;
        context$2$0.t36 = context$2$0.t35 - a;

        if (!(context$2$0.t31 === context$2$0.t36)) {
          context$2$0.next = 19;
          break;
        }

        context$2$0.t37 = 24;
        context$2$0.next = 20;
        break;
      case 19:
        context$2$0.t37 = 25;
      case 20:
        context$2$0.t34 = context$2$0.t37;
      case 21:
        context$2$0.next = context$2$0.t34;
        break;
      case 23:
        return context$2$0.abrupt("return", "first case");
      case 24:
        return context$2$0.abrupt("return", "second case");
      case 25:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this);
  });

  it("should jump to the correct cases", function() {
    check(gen(1), [1, "x"], "first case");
    check(gen(2), [2, "x", "y"], "second case");
  });
});

describe("infinite sequence generator", function() {
  var gen = regeneratorRuntime.mark(function gen(start, step) {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        step = step || 1;
      case 1:
        if (!true) {
          context$2$0.next = 7;
          break;
        }

        context$2$0.next = 4;
        return start;
      case 4:
        start += step;
        context$2$0.next = 1;
        break;
      case 7:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this);
  });

  var limit = regeneratorRuntime.mark(function limit(g, stop) {
    var info;

    return regeneratorRuntime.wrap(function limit$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        if (!true) {
          context$2$0.next = 14;
          break;
        }

        info = g.next();

        if (!info.done) {
          context$2$0.next = 6;
          break;
        }

        return context$2$0.abrupt("return");
      case 6:
        if (!(info.value < stop)) {
          context$2$0.next = 11;
          break;
        }

        context$2$0.next = 9;
        return info.value;
      case 9:
        context$2$0.next = 12;
        break;
      case 11:
        return context$2$0.abrupt("return");
      case 12:
        context$2$0.next = 0;
        break;
      case 14:
      case "end":
        return context$2$0.stop();
      }
    }, limit, this);
  });

  it("should generate a lot of plausible values", function() {
    var g = gen(10, 2);

    assert.deepEqual(g.next(), { value: 10, done: false });
    assert.deepEqual(g.next(), { value: 12, done: false });
    assert.deepEqual(g.next(), { value: 14, done: false });
    assert.deepEqual(g.next(), { value: 16, done: false });

    var sum = 10 + 12 + 14 + 16;

    for (var n = 0; n < 1000; ++n) {
      var info = g.next();
      sum += info.value;
      assert.strictEqual(info.done, false);
    }

    assert.strictEqual(sum, 1017052);
  });

  it("should allow limiting", function() {
    check(limit(gen(10, 3), 20), [10, 13, 16, 19]);
  });
});

describe("generator function expression", function() {
  it("should behave just like a declared generator", function() {
    check(regeneratorRuntime.mark(function callee$2$0(x, y) {
      return regeneratorRuntime.wrap(function callee$2$0$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return x;
        case 2:
          context$3$0.next = 4;
          return y;
        case 4:
          context$3$0.next = 6;
          return x + y;
        case 6:
          return context$3$0.abrupt("return", x * y);
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, callee$2$0, this);
    })(3, 7), [3, 7, 10], 21);
  })
});

describe("generator reentry attempt", function() {
  var gen = regeneratorRuntime.mark(function gen(x) {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        context$2$0.prev = 0;
        context$2$0.next = 3;
        return x;
      case 3:
        context$2$0.sent.next(x);
        context$2$0.next = 10;
        break;
      case 6:
        context$2$0.prev = 6;
        context$2$0.t38 = context$2$0.catch(0);
        context$2$0.next = 10;
        return context$2$0.t38;
      case 10:
        return context$2$0.abrupt("return", x + 1);
      case 11:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this, [[0, 6]]);
  });

  it("should complain with a TypeError", function() {
    var g = gen(3);
    assert.deepEqual(g.next(), { value: 3, done: false });
    var complaint = g.next(g); // Sending the generator to itself.
    assert.ok(complaint.value instanceof Error);
    assert.strictEqual(
      complaint.value.message,
      "Generator is already running"
    );
    assert.deepEqual(g.next(), { value: 4, done: true });
  });
});

describe("completed generator", function() {
  var gen = regeneratorRuntime.mark(function gen() {
    return regeneratorRuntime.wrap(function gen$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        return context$2$0.abrupt("return", "ALL DONE");
      case 1:
      case "end":
        return context$2$0.stop();
      }
    }, gen, this);
  });

  (runningInTranslation ? it : xit)
  ("should refuse to resume", function() {
    var g = gen();

    assert.deepEqual(g.next(), {
      value: "ALL DONE", done: true
    });

    assertAlreadyFinished(g);
  });
});

describe("delegated yield", function() {
  it("should delegate correctly", function() {
    var gen = regeneratorRuntime.mark(function gen(condition) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
          if (!condition) {
            context$3$0.next = 8;
            break;
          }

          context$3$0.next = 5;
          return 1;
        case 5:
          return context$3$0.delegateYield(gen(false), "t39", 6);
        case 6:
          context$3$0.next = 8;
          return 2;
        case 8:
          context$3$0.next = 10;
          return 3;
        case 10:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(true), [0, 1, 0, 3, 2, 3]);
    check(gen(false), [0, 3]);
  });

  it("should cope with empty delegatees", function() {
    var gen = regeneratorRuntime.mark(function gen(condition) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          if (!condition) {
            context$3$0.next = 6;
            break;
          }

          context$3$0.next = 3;
          return 0;
        case 3:
          return context$3$0.delegateYield(gen(false), "t40", 4);
        case 4:
          context$3$0.next = 6;
          return 1;
        case 6:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(true), [0, 1]);
    check(gen(false), []);
  });

  it("should support deeper nesting", function() {
    var outer = regeneratorRuntime.mark(function outer(n) {
      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return n;
        case 2:
          return context$3$0.delegateYield(middle(n - 1, inner(n + 10)), "t41", 3);
        case 3:
          context$3$0.next = 5;
          return n + 1;
        case 5:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this);
    });

    var middle = regeneratorRuntime.mark(function middle(n, plusTen) {
      return regeneratorRuntime.wrap(function middle$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return n;
        case 2:
          return context$3$0.delegateYield(inner(n - 1), "t42", 3);
        case 3:
          context$3$0.next = 5;
          return n + 1;
        case 5:
          return context$3$0.delegateYield(plusTen, "t43", 6);
        case 6:
        case "end":
          return context$3$0.stop();
        }
      }, middle, this);
    });

    var inner = regeneratorRuntime.mark(function inner(n) {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return n;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this);
    });

    check(outer(5), [5, 4, 3, 5, 15, 6]);
  });

  it("should pass sent values through", function() {
    var outer = regeneratorRuntime.mark(function outer(n) {
      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          return context$3$0.delegateYield(inner(n << 1), "t44", 1);
        case 1:
          context$3$0.next = 3;
          return "zxcv";
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this);
    });

    var inner = regeneratorRuntime.mark(function inner(n) {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return n;
        case 2:
          context$3$0.next = 4;
          return context$3$0.sent;
        case 4:
          context$3$0.next = 6;
          return context$3$0.sent;
        case 6:
          return context$3$0.abrupt("return", context$3$0.sent);
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this);
    });

    var g = outer(3);
    assert.deepEqual(g.next(), { value: 6, done: false });
    assert.deepEqual(g.next(1), { value: 1, done: false });
    assert.deepEqual(g.next(2), { value: 2, done: false });
    assert.deepEqual(g.next(4), { value: "zxcv", done: false });
    assert.deepEqual(g.next(5), { value: void 0, done: true });
  });

  it("should be governed by enclosing try statements", function() {
    var outer = regeneratorRuntime.mark(function outer(n) {
      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          context$3$0.next = 3;
          return 0;
        case 3:
          return context$3$0.delegateYield(inner(n), "t45", 4);
        case 4:
          context$3$0.next = 6;
          return 1;
        case 6:
          context$3$0.next = 12;
          break;
        case 8:
          context$3$0.prev = 8;
          context$3$0.t46 = context$3$0.catch(0);
          context$3$0.next = 12;
          return context$3$0.t46.message;
        case 12:
          context$3$0.next = 14;
          return 4;
        case 14:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this, [[0, 8]]);
    });

    var inner = regeneratorRuntime.mark(function inner(n) {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          if (!(n -- > 0)) {
            context$3$0.next = 9;
            break;
          }

          context$3$0.prev = 1;
          if (n === 3) {
            raise(error);
          }
        case 3:
          context$3$0.prev = 3;
          context$3$0.next = 6;
          return n;
        case 6:
          context$3$0.finish(3);
        case 7:
          context$3$0.next = 0;
          break;
        case 9:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this, [[1,, 3]]);
    });

    var error = new Error("thrown");

    check(outer(3), [0, 2, 1, 0, 1, 4]);
    check(outer(5), [0, 4, 3, "thrown", 4]);
  });

  it("should dispatch .thrown exceptions correctly", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          return context$3$0.delegateYield(inner(), "t47", 1);
        case 1:
          context$3$0.prev = 1;
          return context$3$0.delegateYield(inner(), "t48", 3);
        case 3:
          context$3$0.next = 7;
          break;
        case 5:
          context$3$0.prev = 5;
          context$3$0.t49 = context$3$0.catch(1);
        case 7:
          return context$3$0.delegateYield(inner(), "t50", 8);
        case 8:
          return context$3$0.abrupt("return", context$3$0.t50);
        case 9:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[1, 5]]);
    });

    var inner = regeneratorRuntime.mark(function inner() {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return count++;
        case 2:
          return context$3$0.abrupt("return", context$3$0.sent);
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this);
    });

    var count = 0;

    var g = gen();

    assert.deepEqual(g.next(), {
      value: 0,
      done: false
    });

    assert.deepEqual(g.next(), {
      value: 1,
      done: false
    });

    assert.deepEqual(g.throw(new Error("lol")), {
      value: 2,
      done: false,
    });

    assert.deepEqual(g.next("sent"), {
      value: "sent",
      done: true
    });
  });

  (runningInTranslation ? it : xit)
  ("should support any iterable argument", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
          context$3$0.next = 4;
          return "one";
        case 4:
          context$3$0.t51 = context$3$0.sent;
          context$3$0.next = 7;
          return "two";
        case 7:
          context$3$0.t52 = context$3$0.sent;
          context$3$0.next = 10;
          return "three";
        case 10:
          context$3$0.t53 = context$3$0.sent;
          return context$3$0.delegateYield([context$3$0.t51, context$3$0.t52, context$3$0.t53], "t54", 12);
        case 12:
          context$3$0.next = 14;
          return 5;
        case 14:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(), [0, "one", "two", "three", 2, 3, 4, 5]);
  });
});

describe("function declaration hoisting", function() {
  it("should work even if the declarations are out of order", function() {
    var gen = regeneratorRuntime.mark(function gen(n) {
      var increment, halve, decrement;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          increment = function increment(x) {
            return x + 1;
          };

          context$3$0.next = 3;
          return increment(n);
        case 3:
          if (!(n % 2)) {
            context$3$0.next = 10;
            break;
          }

          decrement = function decrement(x) {
            return x - 1;
          };

          halve = function halve(x) {
            return x >> 1;
          };

          context$3$0.next = 8;
          return halve(decrement(n));
        case 8:
          context$3$0.next = 11;
          break;
        case 10:
          // The behavior of function declarations nested inside conditional
          // blocks is notoriously underspecified, and in V8 it appears the
          // halve function is still defined when we take this branch, so
          // "undefine" it for consistency with regenerator semantics.
          halve = void 0;
        case 11:
          context$3$0.next = 13;
          return typeof halve;
        case 13:
          context$3$0.next = 15;
          return increment(increment(n));
        case 15:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(3), [4, 1, "function", 5]);
    check(gen(4), [5, "undefined", 6]);
  });

  it("should work for nested generator function declarations", function() {
    var outer = regeneratorRuntime.mark(function outer(n) {
      var inner;

      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          inner = regeneratorRuntime.mark(// Note that this function declaration comes after everything else
          // in the outer function, but needs to be fully available above.
          function inner(n) {
            return regeneratorRuntime.wrap(function inner$(context$4$0) {
              while (1) switch (context$4$0.prev = context$4$0.next) {
              case 0:
                context$4$0.next = 2;
                return n - 1;
              case 2:
                context$4$0.next = 4;
                return n;
              case 4:
                context$4$0.next = 6;
                return n + 1;
              case 6:
                return context$4$0.abrupt("return", context$4$0.sent);
              case 7:
              case "end":
                return context$4$0.stop();
              }
            }, inner, this);
          });

          context$3$0.next = 3;
          return 0;
        case 3:
          assert.ok(regeneratorRuntime.isGeneratorFunction(inner));
          return context$3$0.delegateYield(inner(n), "t55", 5);
        case 5:
          return context$3$0.abrupt("return", context$3$0.t55);
        case 6:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this);
    });

    check(outer(2), [0, 1, 2, 3], 4);
  });
});

describe("the arguments object", function() {
  it("should work in simple variadic functions", function() {
    var sum = regeneratorRuntime.mark(function sum() {
      var result, i, args$3$0 = arguments;

      return regeneratorRuntime.wrap(function sum$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          result = 0;
          i = 0;
        case 2:
          if (!(i < args$3$0.length)) {
            context$3$0.next = 8;
            break;
          }

          context$3$0.next = 5;
          return result += args$3$0[i];
        case 5:
          ++i;
          context$3$0.next = 2;
          break;
        case 8:
          return context$3$0.abrupt("return", result);
        case 9:
        case "end":
          return context$3$0.stop();
        }
      }, sum, this);
    });

    check(sum(1, 2, 3), [1, 3, 6], 6);
    check(sum(9, -5, 3, 0, 2), [9, 4, 7, 7, 9], 9);
  });

  it("should alias function parameters", function() {
    var gen = regeneratorRuntime.mark(function gen(x, y) {
      var temp, args$3$0 = arguments;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return x;
        case 2:
          ++args$3$0[0];
          context$3$0.next = 5;
          return x;
        case 5:
          context$3$0.next = 7;
          return y;
        case 7:
          --args$3$0[1];
          context$3$0.next = 10;
          return y;
        case 10:
          temp = y;
          y = x;
          x = temp;

          context$3$0.next = 15;
          return x;
        case 15:
          context$3$0.next = 17;
          return y;
        case 17:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(3, 7), [3, 4, 7, 6, 6, 4]);
    check(gen(10, -5), [10, 11, -5, -6, -6, 11]);
  });

  it("should be shadowable by explicit declarations", function() {
    var asParameter = regeneratorRuntime.mark(function asParameter(x, args$3$0) {
      return regeneratorRuntime.wrap(function asParameter$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return x + args$3$0;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, asParameter, this);
    });

    var asVariable = regeneratorRuntime.mark(function asVariable(x) {
      var args$3$0;

      return regeneratorRuntime.wrap(function asVariable$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          args$3$0 = x + 1;
          context$3$0.next = 3;
          return args$3$0;
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, asVariable, this);
    });

    check(asParameter(4, 5), [9]);
    check(asParameter("asdf", "zxcv"), ["asdfzxcv"]);

    check(asVariable(4), [5]);
    check(asVariable("asdf"), ["asdf1"]);
  });

  it("should not get confused by properties", function() {
    var gen = regeneratorRuntime.mark(function gen(obj) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return obj.arguments;
        case 2:
          obj.arguments = "oyez";
          context$3$0.next = 5;
          return obj;
        case 5:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen({ arguments: 42 }), [42, { arguments: "oyez" }]);
  });

  it("supports .callee", function() {
    var gen = regeneratorRuntime.mark(function gen(doYield) {
      var args$3$0 = arguments;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 1;
        case 2:
          if (!doYield) {
            context$3$0.next = 7;
            break;
          }

          context$3$0.next = 5;
          return 2;
        case 5:
          context$3$0.next = 12;
          break;
        case 7:
          context$3$0.next = 9;
          return 3;
        case 9:
          return context$3$0.delegateYield(args$3$0.callee(true), "t56", 10);
        case 10:
          context$3$0.next = 12;
          return 4;
        case 12:
          context$3$0.next = 14;
          return 5;
        case 14:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(false), [1, 3, 1, 2, 5, 4, 5]);
  });
});

describe("catch parameter shadowing", function() {
  it("should leave outer variables unmodified", function() {
    var gen = regeneratorRuntime.mark(function gen(x) {
      var y;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          y = x + 1;
          context$3$0.prev = 1;
          throw x + 2;
        case 5:
          context$3$0.prev = 5;
          context$3$0.t57 = context$3$0.catch(1);
          context$3$0.next = 9;
          return context$3$0.t57;
        case 9:
          context$3$0.t57 += 1;
          context$3$0.next = 12;
          return context$3$0.t57;
        case 12:
          context$3$0.next = 14;
          return x;
        case 14:
          context$3$0.prev = 14;
          throw x + 3;
        case 18:
          context$3$0.prev = 18;
          context$3$0.t58 = context$3$0.catch(14);
          context$3$0.next = 22;
          return context$3$0.t58;
        case 22:
          context$3$0.t58 *= 2;
          context$3$0.next = 25;
          return context$3$0.t58;
        case 25:
          context$3$0.next = 27;
          return y;
        case 27:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[1, 5], [14, 18]]);
    });

    check(gen(1), [3, 4, 1, 4, 8, 2]);
    check(gen(2), [4, 5, 2, 5, 10, 3]);
  });

  it("should not replace variables defined in inner scopes", function() {
    var gen = regeneratorRuntime.mark(function gen(x) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          throw x;
        case 4:
          context$3$0.prev = 4;
          context$3$0.t59 = context$3$0.catch(0);
          context$3$0.next = 8;
          return context$3$0.t59;
        case 8:
          context$3$0.next = 10;

          return function(x) {
            return x += 1;
          }(context$3$0.t59 + 1);
        case 10:
          context$3$0.next = 12;

          return function() {
            var x = arguments[0];
            return x * 2;
          }(context$3$0.t59 + 2);
        case 12:
          context$3$0.next = 14;

          return function() {
            function notCalled(x) {
              throw x;
            }

            context$3$0.t59 >>= 1;
            return context$3$0.t59;
          }();
        case 14:
          context$3$0.next = 16;
          return context$3$0.t59 -= 1;
        case 16:
          context$3$0.next = 18;
          return x;
        case 18:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[0, 4]]);
    });

    check(gen(10), [10, 12, 24, 5, 4, 10]);
    check(gen(11), [11, 13, 26, 5, 4, 11]);
  });

  it("should allow nested catch parameters of the same name", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          raise("e1");
          context$3$0.next = 18;
          break;
        case 4:
          context$3$0.prev = 4;
          context$3$0.t60 = context$3$0.catch(0);
          context$3$0.next = 8;
          return context$3$0.t60;
        case 8:
          context$3$0.prev = 8;
          raise("e2");
          context$3$0.next = 16;
          break;
        case 12:
          context$3$0.prev = 12;
          context$3$0.t61 = context$3$0.catch(8);
          context$3$0.next = 16;
          return context$3$0.t61;
        case 16:
          context$3$0.next = 18;
          return context$3$0.t60;
        case 18:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[0, 4], [8, 12]]);
    });

    check(gen(), ["e1", "e2", "e1"]);
  });
});

describe("empty while loops", function() {
  it("should be preserved in generated code", function() {
    var gen = regeneratorRuntime.mark(function gen(x) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          while (x) {
            // empty while loop
          }

          do {
            // empty do-while loop
          } while (x);

          return context$3$0.abrupt("return", gen.toString());
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var info = gen(false).next();
    assert.strictEqual(info.done, true);
    assert.ok(/empty while loop/.test(info.value));
    assert.ok(/empty do-while loop/.test(info.value));
  });
});

describe("object literals with multiple yields", function() {
  it("should receive different sent values", function() {
    var gen = regeneratorRuntime.mark(function gen(fn) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return "a";
        case 2:
          context$3$0.t62 = context$3$0.sent;
          context$3$0.next = 5;
          return "b";
        case 5:
          context$3$0.t63 = context$3$0.sent;
          context$3$0.next = 8;
          return "c";
        case 8:
          context$3$0.t64 = context$3$0.sent;
          context$3$0.next = 11;
          return "d";
        case 11:
          context$3$0.t65 = context$3$0.sent;
          context$3$0.t66 = fn(context$3$0.t64, context$3$0.t65);
          context$3$0.next = 15;
          return "e";
        case 15:
          context$3$0.t67 = context$3$0.sent;
          context$3$0.next = 18;
          return "f";
        case 18:
          context$3$0.t68 = context$3$0.sent;

          return context$3$0.abrupt("return", {
            a: context$3$0.t62,
            b: context$3$0.t63,
            c: context$3$0.t66,
            d: [context$3$0.t67, context$3$0.t68]
          });
        case 20:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    check(gen(function sum(x, y) {
      return x + y;
    }), ["a", "b", "c", "d", "e", "f"], {
      a: 1,
      b: 2,
      c: 3 + 4,
      d: [5, 6]
    });
  });
});

describe("generator .throw method", function() {
  (runningInTranslation ? it : xit)("should complete generator", function() {
    var gen = regeneratorRuntime.mark(function gen(x) {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 2;
        case 2:
          throw 1;
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var u = gen();

    u.next();

    try {
      u.throw(2);
    } catch (err) {
      assert.strictEqual(err, 2);
    }

    assertAlreadyFinished(u);
  });

  it("should work after the final call to .next", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 1;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var g = gen();
    assert.deepEqual(g.next(), { value: 1, done: false });

    var exception = new Error("unhandled exception");
    try {
      g.throw(exception);
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, exception);
    }
  });

  it("should immediately complete a new-born generator", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          began = true;
          context$3$0.next = 3;
          return 1;
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var began = false;

    var g = gen();
    var exception = new Error("unhandled exception");
    try {
      g.throw(exception);
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, exception);
      assert.strictEqual(began, false);
    }
  });

  it("should not propagate errors handled inside a delegate", function() {
    var outer = regeneratorRuntime.mark(function outer() {
      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          return context$3$0.delegateYield(inner(), "t69", 2);
        case 2:
          context$3$0.next = 7;
          break;
        case 4:
          context$3$0.prev = 4;
          context$3$0.t70 = context$3$0.catch(0);
          return context$3$0.abrupt("return", -1);
        case 7:
          return context$3$0.abrupt("return", 1);
        case 8:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this, [[0, 4]]);
    });

    var inner = regeneratorRuntime.mark(function inner() {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          context$3$0.next = 3;
          return void 0;
        case 3:
          context$3$0.next = 8;
          break;
        case 5:
          context$3$0.prev = 5;
          context$3$0.t71 = context$3$0.catch(0);
          return context$3$0.abrupt("return");
        case 8:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this, [[0, 5]]);
    });

    var g = outer();
    g.next();
    assert.equal(g.throw(new Error('foo')).value, 1);
  });

  it("should propagate errors unhandled inside a delegate", function() {
    var outer = regeneratorRuntime.mark(function outer() {
      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          return context$3$0.delegateYield(inner(), "t72", 2);
        case 2:
          context$3$0.next = 7;
          break;
        case 4:
          context$3$0.prev = 4;
          context$3$0.t73 = context$3$0.catch(0);
          return context$3$0.abrupt("return", -1);
        case 7:
          return context$3$0.abrupt("return", 1);
        case 8:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this, [[0, 4]]);
    });

    var inner = regeneratorRuntime.mark(function inner() {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return void 0;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this);
    });

    var g = outer();
    g.next();
    assert.equal(g.throw(new Error('foo')).value, -1);
  });
});

describe("unqualified function calls", function() {
  it("should have a global `this` object", function() {
    var invoke = regeneratorRuntime.mark(function invoke() {
      return regeneratorRuntime.wrap(function invoke$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return "dummy";
        case 2:
          return context$3$0.abrupt("return", (0, context$3$0.sent)());
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, invoke, this);
    });

    function getThis() {
      return this;
    }

    // This is almost certainly the global object, but there's a chance it
    // might be null or undefined (in strict mode).
    var unqualifiedThis = getThis();

    var g = invoke();
    var info = g.next();

    assert.deepEqual(info, { value: "dummy", done: false });

    info = g.next(getThis);

    // Avoid using assert.strictEqual when the arguments might equal the
    // global object, since JSON.stringify chokes on circular structures.
    assert.ok(info.value === unqualifiedThis);

    assert.strictEqual(info.done, true);
  });
});

describe("yield* expression results", function () {
  it("have correct values", function () {
    var foo = regeneratorRuntime.mark(function foo() {
      return regeneratorRuntime.wrap(function foo$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
          return context$3$0.delegateYield(bar(), "t74", 3);
        case 3:
          return context$3$0.abrupt("return", context$3$0.t74);
        case 4:
        case "end":
          return context$3$0.stop();
        }
      }, foo, this);
    });

    var bar = regeneratorRuntime.mark(function bar() {
      return regeneratorRuntime.wrap(function bar$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 1;
        case 2:
          return context$3$0.abrupt("return", 2);
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, bar, this);
    });

    check(foo(), [0, 1], 2);
  });

  it("can be used in complex expressions", function () {
    var foo = regeneratorRuntime.mark(function foo() {
      return regeneratorRuntime.wrap(function foo$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          return context$3$0.delegateYield(bar(), "t75", 1);
        case 1:
          return context$3$0.delegateYield(bar(), "t76", 2);
        case 2:
          return context$3$0.abrupt("return", context$3$0.t75 + context$3$0.t76);
        case 3:
        case "end":
          return context$3$0.stop();
        }
      }, foo, this);
    });

    var bar = regeneratorRuntime.mark(function bar() {
      return regeneratorRuntime.wrap(function bar$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 2;
        case 2:
          context$3$0.t77 = context$3$0.sent;
          context$3$0.next = 5;
          return 3;
        case 5:
          context$3$0.t78 = context$3$0.sent;
          return context$3$0.abrupt("return", context$3$0.t77 + context$3$0.t78);
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, bar, this);
    });

    function pumpNumber(gen) {
      var n = 0;

      while (true) {
        var res = n > 0 ? gen.next(n) : gen.next();
        n = res.value;
        if (res.done) {
          return n;
        }
      }
    }

    assert.strictEqual(pumpNumber(bar()), 5);
    assert.strictEqual(pumpNumber(foo()), 10);
  });
});

describe("isGeneratorFunction", function() {
  it("should work for function declarations", function() {
    var genFun = regeneratorRuntime.mark(function genFun() {
      return regeneratorRuntime.wrap(function genFun$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, genFun, this);
    });

    // Do the assertions up here to make sure the generator function is
    // marked at the beginning of the block the function is declared in.
    assert.strictEqual(
      regeneratorRuntime.isGeneratorFunction(genFun),
      true
    );

    assert.strictEqual(
      regeneratorRuntime.isGeneratorFunction(normalFun),
      false
    );

    function normalFun() {
      return 0;
    }
  });

  it("should work for function expressions", function() {
    assert.strictEqual(
      regeneratorRuntime.isGeneratorFunction(regeneratorRuntime.mark(function genFun() {
        return regeneratorRuntime.wrap(function genFun$(context$3$0) {
          while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            context$3$0.next = 2;
            return 0;
          case 2:
          case "end":
            return context$3$0.stop();
          }
        }, genFun, this);
      })),
      true
    );

    assert.strictEqual(
      regeneratorRuntime.isGeneratorFunction(function normalFun() {
        return 0;
      }),
      false
    );
  });
});

describe("new expressions", function() {
  it("should be able to contain yield sub-expressions", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
          context$3$0.t79 = context$3$0.sent;
          context$3$0.next = 5;
          return 1;
        case 5:
          context$3$0.t80 = context$3$0.sent;
          context$3$0.next = 8;
          return 2;
        case 8:
          context$3$0.t81 = context$3$0.sent;
          context$3$0.next = 11;
          return new context$3$0.t79(context$3$0.t80, context$3$0.t81);
        case 11:
          return context$3$0.abrupt("return", context$3$0.sent);
        case 12:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    function A(first, second) {
      this.first = first;
      this.second = second;
    }

    var g = gen();

    assert.deepEqual(g.next(), { value: 0, done: false });
    assert.deepEqual(g.next(A), { value: 1, done: false });
    assert.deepEqual(g.next("asdf"), { value: 2, done: false });

    var info = g.next("zxcv");
    assert.strictEqual(info.done, false);
    assert.ok(info.value instanceof A);
    assert.strictEqual(info.value.first, "asdf");
    assert.strictEqual(info.value.second, "zxcv");

    assert.deepEqual(g.next("qwer"), { value: "qwer", done: true });
  });
});

describe("block binding", function() {
  it("should translate block binding correctly", function() {
    "use strict";

    var gen = regeneratorRuntime.mark(function gen() {
      var a$0, a$1, a, a$2, a$3;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          a$0 = 0, a$1 = 1;
          a = 3;
          a$2 = 1;
          context$3$0.next = 5;
          return a$2 + a$0;
        case 5:
          a$3 = 2;
          context$3$0.next = 8;
          return a$3 - 1 + a$1;
        case 8:
          context$3$0.next = 10;
          return a;
        case 10:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var g = gen();

    assert.deepEqual(g.next(), { value: 1, done: false });
    assert.deepEqual(g.next(), { value: 2, done: false });
    assert.deepEqual(g.next(), { value: 3, done: false });
    assert.deepEqual(g.next(), { value: void 0, done: true });
  });

  it("should translate block binding with iife correctly", function() {
    "use strict";

    var gen = regeneratorRuntime.mark(function gen() {
      var arr, x, x$0;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          arr = [];

          for (x = 0; x < 3; x++) {
            (function() {
              var y = x;
              arr.push(function() { return y; });
            }).call(this);
          }
        case 2:
          if (!(x$0 = arr.pop())) {
            context$3$0.next = 7;
            break;
          }

          context$3$0.next = 5;
          return x$0;
        case 5:
          context$3$0.next = 2;
          break;
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var g = gen();

    assert.equal(g.next().value(), 2);
    assert.equal(g.next().value(), 1);
    assert.equal(g.next().value(), 0);
    assert.deepEqual(g.next(), { value: void 0, done: true });
  });
});

describe("newborn generators", function() {
  it("should be able to yield* non-newborn generators", function() {
    var inner = regeneratorRuntime.mark(function inner() {
      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 1;
        case 2:
          context$3$0.t82 = context$3$0.sent;
          context$3$0.next = 5;
          return 2;
        case 5:
          context$3$0.t83 = context$3$0.sent;
          return context$3$0.abrupt("return", [context$3$0.t82, context$3$0.t83]);
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this);
    });

    var outer = regeneratorRuntime.mark(function outer(delegate) {
      return regeneratorRuntime.wrap(function outer$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          return context$3$0.delegateYield(delegate, "t84", 1);
        case 1:
          return context$3$0.abrupt("return", context$3$0.t84);
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, outer, this);
    });

    var n = inner();

    assert.deepEqual(n.next(), {
      value: 1,
      done: false
    });

    var g = outer(n);

    // I would really like to be able to pass 3 to g.next here, but V8
    // ignores values sent to newborn generators, and SpiderMonkey throws
    // a TypeError.
    assert.deepEqual(g.next(), {
      value: 2,
      done: false
    });

    assert.deepEqual(g.next(4), {
      value: [void 0, 4],
      done: true
    });
  });

  it("should support the ignore-initial-yield wrapper idiom", function() {
    var inner = regeneratorRuntime.mark(function inner() {
      var sent1, sent2;

      return regeneratorRuntime.wrap(function inner$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          markers.push(0);
          context$3$0.next = 3;
          return 1;
        case 3:
          sent1 = context$3$0.sent;
          markers.push(2);
          context$3$0.next = 7;
          return 2;
        case 7:
          sent2 = context$3$0.sent;
          markers.push(3);
          return context$3$0.abrupt("return", [sent1, sent2]);
        case 10:
        case "end":
          return context$3$0.stop();
        }
      }, inner, this);
    });

    var markers = [];

    function wrapper(delegate) {
      var gen = (regeneratorRuntime.mark(function callee$3$0() {
        var sent, info;

        return regeneratorRuntime.wrap(function callee$3$0$(context$4$0) {
          while (1) switch (context$4$0.prev = context$4$0.next) {
          case 0:
            context$4$0.next = 2;
            return "ignored";
          case 2:
            sent = context$4$0.sent;

            markers.push(1);
          case 4:
            if ((info = delegate.next(sent)).done) {
              context$4$0.next = 10;
              break;
            }

            context$4$0.next = 7;
            return info.value;
          case 7:
            sent = context$4$0.sent;
            context$4$0.next = 4;
            break;
          case 10:
            markers.push(4);

            return context$4$0.abrupt("return", info.value);
          case 12:
          case "end":
            return context$4$0.stop();
          }
        }, callee$3$0, this);
      }))();

      // Ensure that gen is not newborn and that the next invocation of
      // gen.next(value) can send value to the initial yield expression.
      gen.next();

      return gen;
    }

    var n = inner();

    assert.deepEqual(n.next(), {
      value: 1,
      done: false
    });

    var g = wrapper(n);

    // Unlike in the previous spec, it's fine to pass 3 to g.next here,
    // because g is not newborn, because g.next was already called once
    // before g was returned from the wrapper function.
    assert.deepEqual(g.next(3), {
      value: 2,
      done: false
    });

    assert.deepEqual(g.next(4), {
      value: [3, 4],
      done: true
    });

    // Ensure we encountered the marker points in the expected order.
    assert.deepEqual(markers, [0, 1, 2, 3, 4]);
  });

  it("should allow chaining newborn and non-newborn generators", function() {
    var range = regeneratorRuntime.mark(function range(n) {
      var i;

      return regeneratorRuntime.wrap(function range$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          i = 0;
        case 1:
          if (!(i < n)) {
            context$3$0.next = 7;
            break;
          }

          context$3$0.next = 4;
          return i;
        case 4:
          ++i;
          context$3$0.next = 1;
          break;
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, range, this);
    });

    var chain = regeneratorRuntime.mark(function chain(a, b) {
      return regeneratorRuntime.wrap(function chain$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          return context$3$0.delegateYield(a, "t85", 1);
        case 1:
          return context$3$0.delegateYield(b, "t86", 2);
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, chain, this);
    });

    var y3 = regeneratorRuntime.mark(function y3(x) {
      return regeneratorRuntime.wrap(function y3$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return x;
        case 2:
          context$3$0.next = 4;
          return context$3$0.sent;
        case 4:
          context$3$0.next = 6;
          return context$3$0.sent;
        case 6:
          return context$3$0.abrupt("return", context$3$0.sent);
        case 7:
        case "end":
          return context$3$0.stop();
        }
      }, y3, this);
    });

    var y5 = regeneratorRuntime.mark(function y5(x) {
      return regeneratorRuntime.wrap(function y5$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return x;
        case 2:
          context$3$0.next = 4;
          return context$3$0.sent;
        case 4:
          context$3$0.next = 6;
          return context$3$0.sent;
        case 6:
          context$3$0.next = 8;
          return context$3$0.sent;
        case 8:
          context$3$0.next = 10;
          return context$3$0.sent;
        case 10:
          return context$3$0.abrupt("return", context$3$0.sent);
        case 11:
        case "end":
          return context$3$0.stop();
        }
      }, y5, this);
    });

    check(chain(range(3), range(5)), [0, 1, 2, 0, 1, 2, 3, 4]);

    check(
      chain(y3("foo"), y5("bar")),
      ["foo", 1, 2, "bar", 4, 5, 6, 7]
    );

    var g3 = y3("three");
    assert.deepEqual(g3.next(), {
      value: "three",
      done: false
    });

    var g5 = y5("five");
    assert.deepEqual(g5.next(), {
      value: "five",
      done: false
    });

    // A little easier to read than void 0.
    var undef;
    check(chain(g3, g5), [undef, 1, undef, 3, 4, 5]);
  });
});

describe("labeled break and continue statements", function() {
  it("should be able to exit multiple try statements", function() {
    var gen = regeneratorRuntime.mark(function gen(n, which) {
      var i;

      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          context$3$0.next = 3;
          return 0;
        case 3:
          raise(e1);
        case 4:
          context$3$0.prev = 4;
          context$3$0.next = 7;
          return 1;
        case 7:
          i = 0;
        case 8:
          if (!(i < n)) {
            context$3$0.next = 42;
            break;
          }

          context$3$0.next = 11;
          return i;
        case 11:
          context$3$0.prev = 11;
          raise(e2);
        case 13:
          context$3$0.prev = 13;
          context$3$0.next = 16;
          return 2;
        case 16:
          context$3$0.prev = 16;
          raise(e3);
        case 18:
          context$3$0.prev = 18;
          context$3$0.next = 21;
          return 3;
        case 21:
          context$3$0.prev = 21;
          raise(e4);
        case 23:
          context$3$0.prev = 23;
          context$3$0.next = 26;
          return 4;
        case 26:
          if (!(which === "break")) {
            context$3$0.next = 30;
            break;
          }

          context$3$0.next = 29;
          return "breaking";
        case 29:
          return context$3$0.abrupt("break", 42);
        case 30:
          if (!(which === "continue")) {
            context$3$0.next = 34;
            break;
          }

          context$3$0.next = 33;
          return "continuing";
        case 33:
          return context$3$0.abrupt("continue", 39);
        case 34:
          context$3$0.next = 36;
          return 5;
        case 36:
          context$3$0.finish(23);
        case 37:
          context$3$0.finish(18);
        case 38:
          context$3$0.finish(13);
        case 39:
          ++i;
          context$3$0.next = 8;
          break;
        case 42:
          context$3$0.next = 44;
          return 6;
        case 44:
          context$3$0.finish(4);
        case 45:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[0,, 4], [11,, 13], [16,, 18], [21,, 23]]);
    });

    var e1 = "first";
    var e2 = "second";
    var e3 = "third";
    var e4 = "fourth";

    try {
      check(gen(1, "break"), [
        0, 1, 0, 2, 3, 4, "breaking", 6
      ]);
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, e1);
    }

    try {
      check(gen(3, "continue"), [
        0, 1, 0, 2, 3, 4, "continuing",
        1, 2, 3, 4, "continuing",
        2, 2, 3, 4, "continuing",
        6 // Loop finished naturally.
      ]);
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, e1);
    }

    try {
      check(gen(3, "neither"), [
        0, 1, 0, 2, 3, 4, 5
      ]);
      assert.ok(false, "should have thrown an exception");
    } catch (err) {
      assert.strictEqual(err, e4);
    }
  });
});

describe("for loop with var decl and no update expression", function() {
  // https://github.com/facebook/regenerator/issues/103
  var range = regeneratorRuntime.mark(// https://github.com/facebook/regenerator/issues/103
  function range() {
    var i;

    return regeneratorRuntime.wrap(function range$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
      case 0:
        for (i = 0; false; ) {
        }
      case 1:
      case "end":
        return context$2$0.stop();
      }
    }, range, this);
  });

  it("should compile and run", function() {
    check(range(), []);
  });
});

describe("generator function prototype", function() {
  it("should follow the expected object model", function() {
    var f2 = regeneratorRuntime.mark(function f2() {
      return regeneratorRuntime.wrap(function f2$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 1;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, f2, this);
    });

    // Intentionally at the end to test hoisting.
    var f = regeneratorRuntime.mark(// Intentionally at the end to test hoisting.
    function f() {
      return regeneratorRuntime.wrap(function f$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return this;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, f, this);
    });

    var f = regeneratorRuntime.mark(function f() {
      return regeneratorRuntime.wrap(function f$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 1;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, f, this);
    });

    var GeneratorFunctionPrototype = f.__proto__;
    var GeneratorFunction = GeneratorFunctionPrototype.constructor;

    assert.strictEqual(GeneratorFunction.name, 'GeneratorFunction');
    assert.strictEqual(GeneratorFunction.prototype,
                       GeneratorFunctionPrototype);
    assert.strictEqual(GeneratorFunctionPrototype.prototype.constructor,
                       GeneratorFunctionPrototype);
    assert.strictEqual(GeneratorFunctionPrototype.prototype,
                       f.prototype.__proto__);
    assert.strictEqual(GeneratorFunctionPrototype.__proto__,
                       Function.prototype);

    var g = f();
    assert.ok(g instanceof f);
    assert.strictEqual(g.__proto__, f.prototype);

    assert.deepEqual([], Object.getOwnPropertyNames(f.prototype));
    // assert.deepEqual([], Object.getOwnPropertyNames(g));

    f.prototype.x = 42;

    var g2 = f();
    assert.strictEqual(g2.x, 42);

    var g3 = new f();
    assert.strictEqual(g3.x, 42);

    assert.strictEqual(f.__proto__, f2.__proto__);
    assert.strictEqual(f.hasOwnProperty('constructor'), false);
    assert.strictEqual(f.__proto__.constructor.name, 'GeneratorFunction');

    var f2 = f;
    f = 42;
    var g = f2();

    assert.deepEqual(g.next(), { value: 1, done: false });
    assert.deepEqual(g.next(), { value: void 0, done: true });
    assert.ok(g instanceof f2);
  });
});

describe("for-of loops", function() {
  (runningInTranslation ? it : xit)
  ("should work for Arrays", function() {
    var sum = 0;

    for (var x, t$2$0 = regeneratorRuntime.values([1, 2].concat(3)), t$2$1; !(t$2$1 = t$2$0.next()).done; ) {
      x = t$2$1.value;
      sum += x;
    }

    assert.strictEqual(sum, 6);
  });

  it("should work for generators", function() {
    var value, values = [];

    for (var t$2$0 = regeneratorRuntime.values(range(3)), t$2$1; !(t$2$1 = t$2$0.next()).done; ) {
      value = t$2$1.value;
      values.push(value);
    }

    assert.deepEqual(values, [0, 1, 2]);
  });

  it("should work inside of generators", function() {
    var yieldPermutations = regeneratorRuntime.mark(function yieldPermutations(list) {
      var count, first, genRest, perm, t$3$0, t$3$1, i, prefix, suffix;

      return regeneratorRuntime.wrap(function yieldPermutations$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          if (!(list.length < 2)) {
            context$3$0.next = 4;
            break;
          }

          context$3$0.next = 3;
          return list;
        case 3:
          return context$3$0.abrupt("return", 1);
        case 4:
          count = 0;
          first = list.slice(0, 1);
          genRest = yieldPermutations(list.slice(1));
          t$3$0 = regeneratorRuntime.values(genRest);
        case 8:
          if ((t$3$1 = t$3$0.next()).done) {
            context$3$0.next = 22;
            break;
          }

          perm = t$3$1.value;
          i = 0;
        case 11:
          if (!(i < list.length)) {
            context$3$0.next = 19;
            break;
          }

          prefix = perm.slice(0, i);
          suffix = perm.slice(i);
          context$3$0.next = 16;
          return prefix.concat(first, suffix);
        case 16:
          ++i;
          context$3$0.next = 11;
          break;
        case 19:
          count += i;
        case 20:
          context$3$0.next = 8;
          break;
        case 22:
          return context$3$0.abrupt("return", count);
        case 23:
        case "end":
          return context$3$0.stop();
        }
      }, yieldPermutations, this);
    });

    var count = 0;

    for (var perm, t$2$0 = regeneratorRuntime.values(yieldPermutations([])), t$2$1; !(t$2$1 = t$2$0.next()).done; ) {
      perm = t$2$1.value;
      assert.deepEqual(perm, []);
      ++count;
    }

    assert.strictEqual(count, 1);

    check(yieldPermutations([1]), [[1]], 1);

    check(yieldPermutations([2, 1]), [
      [2, 1],
      [1, 2]
    ], 2);

    check(yieldPermutations([1,3,2]), [
      [1, 3, 2],
      [3, 1, 2],
      [3, 2, 1],
      [1, 2, 3],
      [2, 1, 3],
      [2, 3, 1]
    ], 6);
  });
});

describe("generator return method", function() {
  if (!runningInTranslation) {
    // The return method has not been specified or implemented natively,
    // yet, so these tests need only pass in translation.
    return;
  }

  it("should work with newborn generators", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.next = 2;
          return 0;
        case 2:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this);
    });

    var g = gen();

    assert.deepEqual(g.return("argument"), {
      value: "argument",
      done: true
    });

    assertAlreadyFinished(g);
  });

  it("should behave as if generator actually returned", function() {
    var gen = regeneratorRuntime.mark(function gen() {
      return regeneratorRuntime.wrap(function gen$(context$3$0) {
        while (1) switch (context$3$0.prev = context$3$0.next) {
        case 0:
          context$3$0.prev = 0;
          context$3$0.next = 3;
          return 0;
        case 3:
          context$3$0.next = 8;
          break;
        case 5:
          context$3$0.prev = 5;
          context$3$0.t87 = context$3$0.catch(0);
          assert.ok(false, "should not have executed the catch handler");
        case 8:
          context$3$0.prev = 8;
          executedFinally = true;
          context$3$0.finish(8);
        case 11:
        case "end":
          return context$3$0.stop();
        }
      }, gen, this, [[0, 5, 8]]);
    });

    var executedFinally = false;

    var g = gen();
    assert.deepEqual(g.next(), { value: 0, done: false });

    assert.deepEqual(g.return("argument"), {
      value: "argument",
      done: true
    });

    assert.strictEqual(executedFinally, true);
    assertAlreadyFinished(g);
  });
});
